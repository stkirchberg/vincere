# vincere

> [!CAUTION]
> **Self-rolled Crypto**
>
> I am fully aware of the golden rule: *"Don't roll your own crypto."*
> I did it anyway for the sake of this project.
>
> Please do not use this in production unless you have personally audited the code for security vulnerabilities, as I cannot guarantee it is exploit-free.
>
> For instructions on how to swap these implementations for standard, battle-tested libraries, please refer to the section [Transitioning to Standard Libraries](#5-transitioning-to-standard-libraries) below.

---

## Overview

**vincere** is a lightweight, in-memory messenger written in Go. It demonstrates a complete End-to-End Encryption (E2EE) workflow using a custom implementation of the X25519 Diffie-Hellman key exchange.

## Features

* **Zero Dependencies**: All cryptographic primitives are implemented from scratch in `curve.go` and `aes-ige.go`.
* **Ephemeral Keys**: X25519 keypairs are generated per session and stored only in memory.
* **Constant-Time Arithmetic**: Field operations use constant-time techniques to mitigate timing attacks.
* **E2EE Messaging**: Direct messaging via `@username` triggers a shared secret derivation.
* **Real-time Logs**: A built-in server log frame to monitor cryptographic handshakes and system events.

---

## Architecture & Key Exchange

The following diagram illustrates how two users establish a shared secret using the internal X25519 implementation:

```text
    USER A (Alice)                         USER B (Bob)
    --------------                         ------------
    1. Generate PrivA                      1. Generate PrivB
    2. Compute PubA = X25519(PrivA, 9)     2. Compute PubB = X25519(PrivB, 9)
             |                                      |
             |---------- [ Send PubA ]------------->|
             |<--------- [ Send PubB ]--------------|
             |                                      |
    3. Compute SharedSecret:               3. Compute SharedSecret:
       SS = X25519(PrivA, PubB)               SS = X25519(PrivB, PubA)
             |                                      |
             +------------------ EQUAL -------------+
                                |
                    [ Encrypted Communication ]
```

---

## Technical Deep Dive: Vincere Cryptography

This document provides a detailed look at the internal cryptographic implementation of the `vincere` project, specifically focusing on the manual implementation of Curve25519 in `curve.go`.

### 1. Field Arithmetic & Representation

The implementation uses a custom field element type `fe` representing elements of the prime field $2^{255} - 19$.

* **Radix-51 Representation**: The 255-bit values are stored across 5 `uint64` limbs.
* **Structure**: Each limb holds 51 bits, allowing for efficient multiplication and carries on 64-bit architectures before overflow occurs.
* **Modular Reduction**: The `mul` function handles the prime reduction by utilizing the property $2^{255} \equiv 19 \pmod p$, specifically using the constant `38` for the reduction of higher-order limbs.

### 2. X25519 Montgomery Ladder

The core of the key exchange is the Montgomery Ladder, which performs scalar multiplication $Q = sP$ while being naturally resistant to timing attacks.

* **Constant-Time Swaps (cswap)**: To prevent branch-based timing leaks, the implementation uses bitwise masks to swap coordinates based on the scalar bit.
* **Implementation**: The `cswap` function ensures the exact same instructions are executed regardless of whether the bit is 0 or 1.
* **Bit Clamping**: The scalar is "clamped" in `X25519` to clear the low 3 bits and set the high bit to ensure a fixed bit-length and avoid small-subgroup attacks.

### 3. Cryptographic Workflow in main.go

The messaging layer utilizes the shared secret generated by the curve arithmetic to enable private communication.

* **Key Generation**: `GenerateKeyPair()` creates a 32-byte private key and computes the public key using the base point $x = 9$.
* **Shared Secret**: Derived using `X25519(sender.PrivKey, target.PubKey)`.
* **Encryption**: The shared secret is used to encrypt the message, logged as "IGE E2EE".
* **Memory Security**: Private keys are stored in-memory only and the `X25519` function uses a `defer` block to overwrite the temporary scalar with zeros after computation.

### 4. Current Limitations & Security Notes

As this is a "self-rolled" implementation, it serves as a learning tool rather than a hardened security product:

* **Incomplete Modular Reduction**: The `add` and `sub` functions are simplified and would require more rigorous handling for production use.
* **No Formal Verification**: Unlike standard libraries, this code has not been formally verified or audited for mathematical errors.
* **In-Memory Storage**: Keys are stored in a Go map, making them potentially recoverable from a memory dump if the server is compromised.

---

### 5. Transitioning to Standard Libraries

To upgrade this project to industry standards, follow these steps:

1. **Replace Curve Arithmetic**: Use `golang.org/x/crypto/curve25519`.
2. **Use Authenticated Encryption**: Replace the experimental mode with `crypto/cipher.NewGCM` for AEAD security.

---

### More questions? 

Look at the code. Dumbass. 
